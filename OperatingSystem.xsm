.data
name db "Minex v1.0", 0
bootMsg db "Loading Minex", 0
bootupChar db ".", 0
welcomeMessage db "Welcome to Minex", 0xA, "A Minecraft operating system written in xEC ASM by Andrew Querol", 0xA, "To get started type help", 0

; Command buffer
cmdBuffer db ? 255 ; Ask for a variable with 255 bytes
cmdArgsBuffer db ? 255 ; A buffer to store the arguments seperated by null charaters
terminalBufferRow dd ? 1 ; The current row we are in
terminalBufferCol dd ? 1 ; The current column we are in
terminalBufferSize dd ? 1 ; Make room for the display buffer size

; The command table follows the format as shown
; Command Length, Command, Command Number
; The command number should corispond with the first byte in the actual command definition
cmdTable db 4, "help", 1, 2, "ls", 2, 4, "echo", 3, 8, "shutdown", 4, 4, "edit", 5, 2, "rm", 6, 5, "rmdir", 7, 2, "cp", 8, 2, "cd", 9, 5, "mkdir", 10, 5, "clear", 11, 4, "time", 12
; Commands
cmdHelp db 1, "help", 0x255, "Displays all of the commands", 0
cmdList db 2, "ls", 0x255, "Lists all of the files and directories in the current path", 0
cmdEcho db 3, "echo", 0x255, "Prints out the suppied arguments", 0
cmdShutdown db 4, "shutdown", 0x255, "Shuts down the computer", 0
cmdEdit db 5, "edit", 0x255, "Edits or creates the file specified", 0
cmdRemove db 6, "rm", 0x255, "Removes the file specified, Use rmdir for directories", 0
cmdRemoveDir db 7, "rmdir", 0x255, "Removes the directory specified", 0
cmdCopy db 8, "cp", 0x255, "Copies the specified directory or file to the specified location", 0
cmdChangeDir db 9, "cd", 0x255, "Changes the current directory to the one specified", 0
cmdMakeDir db 10, "mkdir", 0x255, "Makes a directory with the specified name", 0
cmdClear db, 11, "clear", 0x255, "Clears the screens history", 0
cmdTime db, 12, "time", 0x255, "Displays the current Minecraft time", 0

.code
xor ecx, ecx ; Clear ecx
xor ebx, ebx ; Clear ebx
mov terminalBufferRow, 0 ; Set the display buffer row to 0 on startup
mov terminalBufferCol, 0 ; Set the display buffer column to 0 on startup
mov terminalBufferSize, [0x12C11] ; Move the number of coloumns into te Termainal Memory starts at 0x12C11
mul [terminalBufferSize], [0x12C15] ; Multiply by the number of rows

; Display the boot message
push bootMsg ; Push the address of the boot mesage on the stack (The argument)
call displayNullTerminatedString ; Call the display method
add esp, 4 ; Dump the old argument

mov cx, 20 ; Set up the loop counter, loop twenty times before finish booting
startupLoop:
push bootupChar ; Push the address of the bootup char
call displayNullTerminatedString ; Display it
add esp, 4 ; Dump the old argument
loop startupLoop ; Loop until twenty is reached

; Add a line after the boot screen
add dword [terminalBufferRow], 1
mov terminalBufferCol, 0

push welcomeMessage ; Push the welcome message address
call displayNullTerminatedString ; Display the welcome message
add esp, 4 ; Dump the old contents of the argument

mainLoop:
sub esp, 4 ; Allocate 4 bytes to get keyboardInput
call keyboardInput ; Gets the nex char inputed, blocks till a key is pressed
pop eax ; Get the character that was returned

add ecx, 1 ; Increment our key buffer counter
cmp ecx, 255 ; Did we reach out max buffer size?
je resetCharCounter ; If so clear it by jumping past the get command stuff

add dword [terminalBufferCol], 1 ; Increment the column we are in
cmp dword [terminalBufferCol], [0x12C11] ; Comare it to the max number
je resetCharCounter ; If we have reached the max number reset the counter
mov ebx, [0x12C11] ; Move the number of columns into ebx
mul ebx, [terminalBufferRow] ; Multiply it by the curent row
add ebx, [terminalBufferCol] ; Add the curent columns to the result
cmp ebx, [terminalBufferSize] ; Check if it is at the end of the buffer
jg haltCpu ; For now just reset the char counter
je haltCpu
add dword ebx, [0x12C19] ; And finally add the base offset to the calculated offset
mov byte [ebx], eax ; Finally put the byte value of the character into the buffer

cmp byte eax, 0xA ; Is it enter?
jne mainLoop ; If it isn't enter continue getting keys until enter is pressed or we reach 255 chars

mov [ebx], 0 ; Remove the enter char
add [terminalBufferRow], 1 ; Increment the rows
mov terminalBufferCol, 0 ; Reset the position in the columns

sub esp, 4 ; Allocate 4 bytes to get the command number
call getCommand ; Call get command to get the command number
pop eax ; Get the command number that was pressed

;call getArguments ; Gets and stores the arguments into cmdArgsBuffer
;cmp eax, byte [cmdHelp] ; Compare eax to the first byte stored in cmdHelp
;je help ; Jump to help
;cmp eax, byte [cmdList] ; Compare eax to the first byte stored in cmdList
;je list ; Jump to list

resetCharCounter:
xor ecx, ecx ; Clear ecx(The counter) because enter was pressed
jmp mainLoop ; And repeat


;
; Gets the next char from the keyboard
;
keyboardInput:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Push the old value of eax onto the stack
getChar:
inp eax, 0x122 ; Get the next character from the keyboard buffer
cmp eax, 0 ; Is it a null char?
je getChar ; If it is try again
mov [ebp + 8], eax ; Else move it into the first argument spot(The return value)
pop eax ; Pop the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Gets the command
;
getCommand:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push ecx ; Push the old value of ecx onto the stack
push eax ; Push the old value of eax onto the stack
xor ecx, ecx ; Clear ecx
xor eax, eax ; Clear eax

;cmdParseLoop:
;mov eax, byte [cmdTable]
;add eax, ecx
;add ecx, [eax + 1] ; Increment ecx by the previous commands size
;cmp [ebp + 8],
;cmp
;jne cmdParseLoop ; Jump if the command wasn't found

pop eax ; Pop the old value back into eax
pop ecx ; Pop the old value back into ecx
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Dispalys a null terminated string to the terminal
;
displayNullTerminatedString:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Store the old value of eax
push ebx ; store the old value of ebx
push ecx ; Store the old value of ecx
xor ecx, ecx ; Clear ecx
mov eax, [ebp + 8] ; Move the address of the string into eax

; The display loop
displayLoop:
; Get the new offset
mov ecx, dword [0x12C11] ; Move into ecx the number of columns
mul ecx, dword [terminalBufferRow] ; Multiply into ecx the curent row we are in
add ecx, dword [terminalBufferCol] ; Add the curent column we are in

; Comparisons
cmp ecx, dword [terminalBufferSize] ; Lets check if its at the end of the display buffer
jg haltCpu
je haltCpu
cmp byte [eax], 0xA ; Lets see if it is an enter
je onEnterPress ; If its enter lets do special stuff for it
cmp byte [eax], 0 ; Lets see if it's the null terminator
je displayEnd ; Jump to the end of the sub routine

; Actual writing to the display buffer
mov ebx, dword [0x12C19] ; The value at this location is the start address of the terminal buffer, usually just the next four bytes
add ebx, ecx ; Add the curent offset to the base address
mov byte [ebx], [eax] ; Move the char into the terminal buffer

; Incrementing
add [terminalBufferCol], 1 ; Increment the display offset
add eax, 1 ; Increment the offset in the string
jmp displayLoop

; Enter handling
onEnterPress:
add eax, 1 ; Increment the string offset
add [terminalBufferRow], 1 ; Add one to the row counter
mov terminalBufferCol, 0 ; Rest the column counter
jmp displayLoop ; Jump back to display more characters

; The end of the display string function
displayEnd:
pop ecx ; Retreive the old value of ecx
pop ebx ; Restore the old value of ebx
pop eax ; Retreive the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return


;
; Stops the computer, currently only gets called on shutdown
;
haltCpu:
hlt ; This opcode halts(Shutsdown) the cpu