.data
name db "Minex v1.0", 0
bootMsg db "Loading Minex", 0
bootupChar db ".", 0
welcomeMessage db "Welcome to Minex", 0xA, "A Minecraft operating system written in xEC ASM by Andrew Querol", 0xA, "To get started type help", 0

; Command buffer
cmdBuffer db ? 255 ; Ask for a variable with 255 bytes
cmdArgsBuffer db ? 255 ; A buffer to store the arguments seperated by null charaters
terminalBufferPosition dd ? 1 ; Define one Double Word for storing the position of the display buffer
terminalBufferSize dd ? 1 ; Make room for the display buffer size

; The command table follows the format as shown
; Command Length, Command, Command Number
; The command number should corispond with the first byte in the actual command definition
cmdTable db 4, "help", 1, 2, "ls", 2, 4, "echo", 3, 8, "shutdown", 4, 4, "edit", 5, 2, "rm", 6, 5, "rmdir", 7, 2, "cp", 8, 2, "cd", 9, 5, "mkdir", 10, 5, "clear", 11, 4, "time", 12
; Commands
cmdHelp db 1, "help", 0x255, "Displays all of the commands", 0
cmdList db 2, "ls", 0x255, "Lists all of the files and directories in the current path", 0
cmdEcho db 3, "echo", 0x255, "Prints out the suppied arguments", 0
cmdShutdown db 4, "shutdown", 0x255, "Shuts down the computer", 0
cmdEdit db 5, "edit", 0x255, "Edits or creates the file specified", 0
cmdRemove db 6, "rm", 0x255, "Removes the file specified, Use rmdir for directories", 0
cmdRemoveDir db 7, "rmdir", 0x255, "Removes the directory specified", 0
cmdCopy db 8, "cp", 0x255, "Copies the specified directory or file to the specified location", 0
cmdChangeDir db 9, "cd", 0x255, "Changes the current directory to the one specified", 0
cmdMakeDir db 10, "mkdir", 0x255, "Makes a directory with the specified name", 0
cmdClear db, 11, "clear", 0x255, "Clears the screens history", 0
cmdTime db, 12, "time", 0x255, "Displays the current Minecraft time", 0

.code
xor ecx, ecx ; Clear ecx
xor ebx, ebx ; Clear ebx
mov terminalBufferPosition, 0 ; Set the display buffer position to 0 on startup
mov terminalBufferSize, [0x12C11] ; Move the number of coloumns into te Termainal Memory starts at 0x12C11
mul [terminalBufferSize], [0x12C15] ; Multiply by the number of rows

; Display the boot message
push bootMsg ; Push the address of the boot mesage on the stack (The argument)
call displayNullTerminatedString ; Call the display method
add esp, 4 ; Dump the old argument

mov cx, 20 ; Set up the loop counter, loop twenty times before finish booting
startupLoop:
push bootupChar ; Push the address of the bootup char
call displayNullTerminatedString ; Display it
add esp, 4 ; Dump the old argument
loop startupLoop ; Loop until twenty is reached

push welcomeMessage ; Push the welcome message address
call displayNullTerminatedString ; Display the welcome message
add esp, 4 ; Dump the old contents of the argument

mainLoop:
sub esp, 4 ; Allocate 4 bytes to get keyboardInput
call keyboardInput ; Gets the nex char inputed, blocks till a key is pressed
pop eax ; Get the character that was returned

add ecx, 1 ; Increment our key buffer counter
cmp ecx, 255 ; Did we reach out max buffer size?
je resetCharCounter ; If so clear it by jumping past the get command stuff

add [terminalBufferPosition], 1
cmp [terminalBufferPosition], [terminalBufferSize]
je resetCharCounter
mov ebx, [0x12C19]
add ebx, [terminalBufferPosition]
mov [ebx], eax

cmp eax, 0xA ; Is it enter?
jne mainLoop ; If it isn't enter continue getting keys until enter is pressed or we reach 255 chars

add [terminalBufferPosition], [0x12C11] ; Add a line to the terminal buffer
cmp [terminalBufferPosition], [terminalBufferSize] ; Check if it is the last line
jg resetCharCounter ; For now just reset the char counter

sub esp, 4 ; Allocate 4 bytes to get the command number
call getCommand ; Call get command to get the command number
pop eax ; Get the command number that was pressed

;call getArguments ; Gets and stores the arguments into cmdArgsBuffer
;cmp eax, byte [cmdHelp] ; Compare eax to the first byte stored in cmdHelp
;je help ; Jump to help
;cmp eax, byte [cmdList] ; Compare eax to the first byte stored in cmdList
;je list ; Jump to list

resetCharCounter:
xor ecx, ecx ; Clear ecx(The counter) because enter was pressed
jmp mainLoop ; And repeat

;
; Gets the next char from the keyboard
;
keyboardInput:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Push the old value of eax onto the stack
getChar:
inp eax, 0x122 ; Get the next character from the keyboard buffer
cmp eax, 0 ; Is it a null char?
je getChar ; If it is try again
mov [ebp + 8], eax ; Else move it into the first argument spot(The return value)
pop eax ; Pop the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return

;
; Gets the command
;
getCommand:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push ecx ; Push the old value of ecx onto the stack
push eax ; Push the old value of eax onto the stack
xor ecx, ecx ; Clear ecx
xor eax, eax ; Clear eax

;cmdParseLoop:
;mov eax, byte [cmdTable]
;add eax, ecx
;add ecx, [eax + 1] ; Increment ecx by the previous commands size
;cmp [ebp + 8],
;cmp
;jne cmdParseLoop ; Jump if the command wasn't found

pop eax ; Pop the old value back into eax
pop ecx ; Pop the old value back into ecx
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return

;
; Dispalys a null terminated string to the terminal
;
displayNullTerminatedString:
push ebp ; Push the curent base pointer
mov ebp, esp ; Move the curent stack pointer into the base pointer
push eax ; Store the old value of eax
push ebx ; store the old value of ebx
push ecx ; Store the old value of ecx
xor ecx, ecx ; Clear ecx
mov eax, [ebp + 8] ; Move the address of the string into eax
mov ecx, [terminalBufferPosition] ; Move into ecx the position we are in the terminals buffer

displayLoop:
cmp ecx, [terminalBufferSize] ; Check if were at the end of the display buffer
jg displayEnd ; If so jump to the end
mov ebx, [0x12C19] ; The value at this location is the start address of the terminal buffer, usually just the next four bytes
add ebx, ecx ; Add the curent offset to the base address
mov [ebx], [eax] ; Move the char into the 
add ecx, 1 ; Increment the display offset
add eax, 1 ; Increment the offset in the string
cmp [eax], 0xA ; Lets see if it is an enter
jne dispayLoopEnd ; If it isn't an enter continue going
add ecx, [0x12C11] ; Add the number of coloumns to the offset if it has enter in it
dispayLoopEnd:
cmp [eax], 0 ; Lets see if it's the null terminator
jne displayLoop ; If it isn't continue displaying

displayEnd:
mov dword terminalBufferPosition, ecx ; Store the new display buffer offset
pop ecx ; Retreive the old value of ecx
pop ebx ; Restore the old value of ebx
pop eax ; Retreive the old value of eax
mov esp, ebp ; Move the stack pointer to the curent base pointer
pop ebp ; Restore the last base pointer
ret ; return

;
; Stops the computer, currently only gets called on shutdown
;
haltCpu:
hlt ; This opcode halts(Shutsdown) the cpu